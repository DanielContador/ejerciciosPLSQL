--CLASE 1
--Se crea el procedimiento con parametro, el de tipo in es de entrada y significa que servirá
--para aplicarlo en un where o algo asi, y no se le pueden asignar valores, pero al OUT si, actua como variable


CREATE PROCEDURE SP_CALCULAR_LIQ_MENSUAL(PFECHA1 IN VARCHAR2, PCANT_EMP OUT NUMBER)
IS
CURSOR C_LIQUIDACION(PFECHA VARCHAR2) IS
    SELECT PFECHA AS FECHA, EMPLOYEE_ID, FIRST_NAME||' '||LAST_NAME AS NOMBRE, SALARY FROM EMPLOYEES;

BEGIN
--Eejemplo en el que se utiliza en procedimiento para guardar en una tabla los datos que se acaban de calcular.
EXECUTE IMMEDIATE 'TRUNCATE TABLE LIQUIDACION_MENSUAL';
PCANT_EMP:=0;
    FOR R_L IN C_LIQUIDACION(PFECHA1) LOOP
        INSERT INTO LIQUIDACION_MENSUAL (....)
        VALUES (R_L.BLABLA)
        PCANT_EMP:=PCANT_EMP+1;
    END LOOP;
END;

--En este caso se llama al procedimiento pero
--se declara el tipo de dato del parametro de cantidad de empleados

DECLARE
V_CANT_EMP_PROCESA NUMBER(4);
BEGIN
    SP_CALCULAR_LIQ_MENSUAL(:FECHA,V_CANT_EMP_PROCESA);
   --DBMSOUTPUT...
END;



--CLASE 2

--PROCEDIMIENTOS ALMACENADOS
--SIRVEN PARA AGRUPAR Y REUTILIZAR CODIGO
--EN LA UNIDAD VAMOS A VER PROCEDIMIENTOS, FUNCIONES, PACKAGE, TRIGGER.(CREATE)DDL


--Creacion de un procedimiento
--Luego de compilarlo se deberia borrar este codigo
--Despues de compilado si quiero modificarlo se presiona el icono de engranaje


CREATE PRCEDURE SP_CUENTA_DIGITOS
IS--Es igual que un declare...
BEGIN
    DBMS_OUTPUT.PUT_LINE(LENGTH('AAA'));
END;

--PARA EJECUTAR EL PROCEDIMIENTO---------------

--Si se quiere utilizar fuera de un bloque anonimo va con EXECUTE

--si va en un bloque anonimo se escribe como


BEGIN 
    SP_CUENTA_DIGITOS;

END;

--aplicando parametro al mismo codigo

CREATE PRCEDURE SP_CUENTA_DIGITOS(TEXTO IN VARCHAR2)
IS--Es igual que un declare...
BEGIN
    DBMS_OUTPUT.PUT_LINE(LENGTH(TEXTO));
    END;
--EJECUTANDOLO


BEGIN 
    SP_CUENTA_DIGITOS(TEXTO=>'ALGO');

END;


--Ejemplo 2

CREATE PROCEDURE SP_CIFRAR(TEXTO IN VARCHAR2, CIFRADO OUT VARCHAR2)
IS
BEGIN
    CIFRADO:=SUBSTR(TEXTO,1,1)||'BLA';
END;

--Al ejecutarlo

--los de OUT se usan cuando diga (el procedimiento debe devolver tal valor)
DECLARE
--Declaro la variable para que me reciba el valor
--del parametro de salida.
V_RESULT VARCHAR2(100);
BEGIN
    SP_CIFRAR(TEXTO=>'BLA', CIFRADO=>V_RESULT):

END;


--ejemplo 3

CREATE PROCEDURE SP_PROCESA_ADMINISTRADOR
IS
CURSOR C_ADMINISTRADOR IS
    SELECT NUMRUN_ADM, DVRUN_ADM, PNOMBRE_ADM, APPATERNO_ADM
    FROM ADMINISTRADOR;
BEGIN
    FOR R_AD IN C_ADMINISTRADOR LOOP
    DBMS_OUTPUT.PUT_LINE(R_AD.NUMRUN_ADM);
    
    END LOOP;
END SP_PROCESA_ADMINISTRADOR;


--Ejemplo 4

create or replace PROCEDURE SP_MOSTRAR_COMUNA(PLETRA_CONSULTA IN VARCHAR2, PCANT_COMUNAS OUT NUMBER)

IS

CURSOR C_COMUNA(PLETRA_COMUNA VARCHAR2) IS

  SELECT * FROM COMUNA WHERE SUBSTR(NOMBRE_COMUNA,1,1)=PLETRA_COMUNA;

BEGIN

PCANT_COMUNAS:=0;

  FOR R_C IN C_COMUNA(PLETRA_COMUNA=>PLETRA_CONSULTA) LOOP

    DBMS_OUTPUT.PUT_LINE(R_C.ID_COMUNA||' '||R_C.NOMBRE_COMUNA);

    PCANT_COMUNAS:=PCANT_COMUNAS+1;

  END LOOP;

END;

--ejecucion 

DECLARE

V_CANT NUMBER(5);

BEGIN

  SP_MOSTRAR_COMUNA(PLETRA_CONSULTA=>'C',PCANT_COMUNAS=>V_CANT);

  DBMS_OUTPUT.PUT_LINE('EXISTEN '||V_CANT||' COMUNA/S CON LA LETRA CONSULTADA.');

END;
---------------------------------------------

--EJECRICIO 1(Funciones almacenadas)


--debe devolver un valor(esa es la diferencia con procedimiento)
--tiene la clausula RETURN
--la funcion se puede incluir en sentencia SELECT
--la funcion se invoca no se ejecuta...

--se ejecuta y se guarda para compilarlo
CREATE FUNCTION FN_SUMA_NUMERO RETURN NUMBER
IS
BEGIN
    RETURN 1+1;

END;

--se puede invocar en un bloque anonimo
--no se puede hacer EXECUTE
--El resultado se puede almacenar en una variable

DECLARE
V_RESULTADO NUMBER(4);
BEGIN
    V_RESULTADO:=FN_SUMA_NUMERO(PNUM1=>10,PNUM2=>10);
    dbms_output.put_line(V_RESULTADO);
END;

--EJEMPLO 2

CREATE FUNCTION FN_NOMBRE_COMUNA(PID_COM NUMBER) RETURN VARCHAR2
IS
V_NOMBRE_COMUNA VARCHAR2(100);
--En las funciones la variable se desclara ahi mismo
BEGIN
    SELECT NOMBRE_COMUNA INTO V_NOMBRE_COMUNA WHERE ID_COMUNA=PID_COM;
    RETURN v_NOMBRE_COMUNA;
EXCEPTION
    WHEN OTHERS THEN
        RETURN 'IDENTIFICADOR DE COMUNA NOEXST';
END;
--Las funciones siempre deben retornar un valor
BEGIN
    DBMS_OUTPUT.PUT_LINE(FN_NOMBRE_COMUNA(1));
END;

SELECT ID_COMUNA, FN_NOMBRE_COMUNA(ID_COMUNA) FROM COMUNA;


CREATE FUNCTION FN_LONGITUD_TEXTO(TEXTO VARCHAR2) RETURN NUMBER
IS
BEGIN
    RETURN NVL(LENGTH(TEXTO),0);
END;


SELECT FN_LONGITUD_TEXTO(PNOMBRE_ADM),
FN_LONGITUD_TEXTO(SNOMBRE_ADM),
FN_LONGITUD_TEXTO(APPATERNO_ADM) 
FROM ADMINISTRADOR;

--EJERCICIO 3.1 -1
--EJEMP
SELECT 
ANNO_MES_PCGC, ID_EDIF, NRO_DEPTO, NUMRUN_RPGC
FROM GASTO_COMUN
WHERE TO_CHAR(FECHA_PAGO_GC, 'YYYYMM')='202205';

--INICIO BLOQUE ANONIMO
DECLARE
CURSOR C_GASTO_COMUN_PAGO(FECHA_YYYYMM VARCHAR2) IS
    SELECT 
    ANNO_MES_PCGC, ID_EDIF, NRO_DEPTO, NUMRUN_RPGC
    FROM GASTO_COMUN
    WHERE TO_CHAR(FECHA_PAGO_GC, 'YYYYMM')=FECHA_YYYYMM;
    
V_EXISTE_PAGO NUMBER(1);
BEGIN

EXECUTE IMMEDIATE 'TRUNCATE TABLE GASTO_COMUN_PAGO_CERO';
    FOR R_GASTO IN C_GASTO_COMUN_PAGO(:FECHA_YYYYMM) LOOP
        DBMS_OUTPUT.PUT_LINE(R_GASTO.ANNO_MES_PCGC||' '||R_GASTO.ID_EDIF||' '||R_GASTO.NRO_DEPTO);
        SELECT COUNT(*) INTO V_EXISTE_PAGO FROM PAGO_GASTO_COMUN
        WHERE ANNO_MES_PCGC=R_GASTO.ANNO_MES_PCGC AND ID_EDIF=R_GASTO.ID_EDIF AND NRO_DEPTO=R_GASTO.NRO_DEPTO;
        /*La logica es que se cuentan todos los resultados de la tabla cuando los datos de la fecha de pago es igual
        a la del cobro,y esto va a arrojar varios resultados, pero cuando no coincidan será 0 y entra en la codicion.
        tambien se incluye el id del edificio y nro de depto para especificar a que depto corresponde cada pago*/
        IF V_EXISTE_PAGO = 0 THEN
            DBMS_OUTPUT.PUT_LINE(R_GASTO.ANNO_MES_PCGC||' '||R_GASTO.ID_EDIF||' '||R_GASTO.NRO_DEPTO);
            INSERT INTO GASTO_COMUN_PAGO_CERO VALUES
            (R_GASTO.ANNO_MES_PCGC, R_GASTO.ID_EDIF, 
            FN_NOMBRE_EDIFICIO(PID_EDIF=>R_GASTO.ID_EDIF),
            FN_RUN_ADMIN_EDIF(PID_EDIF=>R_GASTO.ID_EDIF),
            FN_NOMBRE_ADMIN_EDIF(PRUN_ADMIN=>FN_RUN_ADMIN_EDIF(PID_EDIF=>R_GASTO.ID_EDIF)),
            R_GASTO.NRO_DEPTO,
             R_GASTO.NUMRUN_RPGC,
            FN_NOMBRE_RESPONSABLE_PAGO(R_GASTO.NUMRUN_RPGC)
            ,0,'BLABLA');
        END IF;
    END LOOP;

END;
-- Creacion de funciones para obtener cada dato

CREATE FUNCTION FN_NOMBRE_EDIFICIO(PID_EDIF NUMBER) RETURN VARCHAR2
IS
V_NOMBRE_EDIFICIO VARCHAR2(100);
BEGIN
    SELECT NOMBRE_EDIF INTO V_NOMBRE_EDIFICIO FROM  EDIFICIO WHERE ID_EDIF=PID_EDIF;
    RETURN V_NOMBRE_EDIFICIO;
EXCEPTION
    WHEN OTHERS THEN
        RETURN 'EDIFICIO SIN NOMBRE';
END;


CREATE FUNCTION FN_RUN_ADMIN_EDIF(PID_EDIF NUMBER) RETURN NUMBER
IS
    V_NUM_RUN_ADMIN NUMBER(10);
BEGIN
    SELECT NUMRUN_ADM INTO V_NUM_RUN_ADMIN
    FROM EDIFICIO WHERE ID_EDIF=PID_EDIF;
    
    RETURN V_NUM_RUN_ADMIN;
EXCEPTION
    WHEN OTHERS THEN
    RETURN 0;

END;



CREATE FUNCTION FN_NOMBRE_ADMIN_EDIF(PRUN_ADMIN NUMBER) RETURN VARCHAR2
IS
V_NOMBRE_ADMIN VARCHAR2(100);
BEGIN
    SELECT PNOMBRE_ADM||' '||SNOMBRE_ADM||' '||APPATERNO_ADM||' '||APMATERNO_ADM AS INTO V_NOMBRE_ADMIN
    FROM ADMINISTRADOR
    WHERE NUMRUN_ADM=PRUN_ADMIN;
    
    RETURN V_NOMBRE_ADMIN;
EXCEPTION
    WHEN OTHERS THEN
    RETURN 'NO SE ENCONTRO NOMBRE';

END;

CREATE FUNCTION FN_NOMBRE_RESPONSABLE_PAGO(PRUN_RES NUMBER) RETURN VARCHAR2
IS
V_NOMBRE_RES VARCHAR2(100);
BEGIN
SELECT PNOMBRE_RPGC||' '||SNOMBRE_RPGC||' '||APPATERNO_RPGC||' '||APMATERNO_RPGC INTO V_NOMBRE_RES
FROM RESPONSABLE_PAGO_GASTO_COMUN WHERE NUMRUN_RPGC=PRUN_RES;

RETURN V_NOMBRE_RES;

EXCEPTION
    WHEN OTHERS THEN
    RETURN 'RESPONSABLE NO ENCONTRADO';


END;

-------------------------PACKAGE------------------------------------------------------------


--Los packages son codigos que contienen otros codigos
--es una caja donde se van guardando procedimientos, funciones o variables
--Todos se cargan en memoria, lo que permite que se puedan leer multiples objetos a la vez, tiene mejor performance
--lo de tener que ir al disco duro hace que se ponga lento
--se puede usar un package en un procedimiento o dentro de otro package, etc...
/*
ventajas
1-La modularidad, ya que permite encapsular elementos, puedes crear elementos publicos
y hay otros que son privados que solo se pueden usar dentro del package y no afuera.
2-Ocultar informacion, para que no vean el codigo que se va a ejecutar en si
ESPECIFICACION
-
CUERPO
Todo lo que va en la especificacion es publico
y el cuerpo es privado


*/

---------------------------------------------------------------

----------SUMA--------------------------------------
CREATE PROCEDURE SP_SUMA_NUMERO(PNUM1 NUMBER, PNUM2 NUMBER)
IS
BEGIN
    DBMS_OUTPUT.PUT_LINE('EL RESULTADO ES: '||(PNUM1+PNUM2));

END;


EXECUTE SP_SUMA_NUMERO(PNUM1=>1,PNUM2=>1);

-----------------RESTA---------------------

CREATE PROCEDURE SP_RESTA_NUMERO(PNUM1 NUMBER, PNUM2 NUMBER)
IS
BEGIN
    DBMS_OUTPUT.PUT_LINE('EL RESULTADO ES: '||(PNUM1-PNUM2));

END;


EXECUTE SP_RESTA_NUMERO(PNUM1=>1,PNUM2=>1);
-------------------------------------------


-----------------MULTIPLICACION---------------------

CREATE PROCEDURE SP_MULTIPLICA_NUMERO(PNUM1 NUMBER, PNUM2 NUMBER)
IS
BEGIN
    DBMS_OUTPUT.PUT_LINE('EL RESULTADO ES: '||(PNUM1*PNUM2));

END;


EXECUTE SP_MULTIPLICA_NUMERO(PNUM1=>89,PNUM2=>250);
-------------------------------------------

---FUNCION PARA EL LARGO-----------------
CREATE FUNCTION FN_LARGO_TEXTO(PTEXTO VARCHAR2) RETURN NUMBER
IS

BEGIN
RETURN LENGTH(PTEXTO);
END;
------------------------------------------
-----EJECUCION----------------
BEGIN
DBMS_OUTPUT.PUT_LINE('EL LARGO DEL TEXTO '||'PABLITOCLAVOUNCLAVITOQUECLAVITOCLAVOPABLITO '||'ES: '||FN_LARGO_TEXTO(PTEXTO=>'PABLITOCLAVOUNCLAVITOQUECLAVITOCLAVOPABLITO'));

END;



SELECT FN_LARGO_TEXTO(PTEXTO=>PNOMBRE) LARGO_PRIMER_NOMBRE, PNOMBRE, SNOMBRE, APATERNO, AMATERNO
FROM MEDICO;



BEGIN

DBMS_OUTPUT.PUT_LINE(FN_LARGO_TEXTO(PTEXTO=>:TEXTO));
END;


----------------PACKAGE-------------------------------

CREATE PACKAGE PKG_PRIMER_PACKAGE
IS
--Todo lo que escriba aqui es publico (encabezado)

--si llamo a un procedimiento que ejecute antes no lo va a reconocer, ya que es otro que se almacena en el package y no en memoria como el otro
    FUNCTION FN_LARGO_TEXTO(PTEXTO VARCHAR2) RETURN NUMBER;
    PROCEDURE SP_SUMA_NUMERO(PNUM1 IN NUMBER, PNUM2 IN NUMBER);
--en el cuerpo se define lo que haran estas funciones y procedimientos
END;

CREATE PACKAGE BODY PKG_PRIMER_PACKAGE
IS
    FUNCTION FN_LARGO_TEXTO(PTEXTO VARCHAR2) RETURN NUMBER;
        IS
        
        
        BEGIN
        RETURN LENGTH(PTEXTO);
    END FN_LARGO_TEXTO;
    ----------------------------------------------
    PROCEDURE SP_MULTIPLICA_NUMERO(PNUM1 NUMBER, PNUM2 NUMBER)
    IS
    BEGIN
        DBMS_OUTPUT.PUT_LINE('EL RESULTADO ES: '||(PNUM1*PNUM2));
    
    END SP_MULTIPLICA_NUMERO;
----------------------------------------------

END;
--EJECUCION DE PROCEDIMIENTO A TRAVES DE UN PACKAGE
EXECUTE PKG_PRIMER_PACKAGE.SP_SUMA_NUMERO(PNUM1=>10, PNUM2=>12);

BEGIN
    DBMS_OUTPUT.PUT_LINE(PKG_PRIMER_PACKAGE.FN_LARGO_TEXTO('AAA'));
END;


--body package-----------

create or replace PACKAGE BODY PKG_PRIMER_PACKAGE
IS
    FUNCTION FN_LARGO_TEXTO(PTEXTO VARCHAR2) RETURN NUMBER
        IS
        BEGIN
        
        RETURN LENGTH(PTEXTO);
    END FN_LARGO_TEXTO;

    PROCEDURE SP_SUMA_NUMERO(PNUM1 NUMBER, PNUM2 NUMBER)
    IS
    BEGIN
        DBMS_OUTPUT.PUT_LINE('EL RESULTADO ES: '||(PNUM1+PNUM2));

    END SP_SUMA_NUMERO;
    
    
    --Si aca yo escribiera una funcion que no declaro en el encabezado seria privada.
    --si yo quiero incorporar un funcion privada dentro de otro procedimiento del package, tengo que ponerla antes del procedimiento en cuestion


END;


--Crear un package de tarea


CREATE PACKAGE PKG_TAREA
IS
    PROCEDURE SP_FILAS_TABLA(ANNO_ATENCION IN NUMBER, PTOTAL OUT NUMBER);
    FUNCTION FN_CONCATENAR(PVALOR1 VARCHAR2, PVALOR2 VARCHAR2) RETURN VARCHAR2;
    

END;

--puede que haya un problema con hacer un select into a un parametro de salida...
CREATE PACKAGE BODY PKG_TAREA
IS
    PROCEDURE SP_FILAS_TABLA(ANNO_ATENCION IN NUMBER, PTOTAL OUT NUMBER)
    IS
    BEGIN
    SELECT COUNT(*) INTO PTOTAL FROM ATENCION WHERE EXTRACT(YEAR FROM FECHA_ATENCION)=ANNO_ATENCION;
    DBMS_OUTPUT.PUT_LINE('EL TOTAL DE ATENCIONES DEL AÑO ' ||ANNO_ATENCION||' ES ' ||PTOTAL);
    END SP_FILAS_TABLA;
    
    
    FUNCTION FN_CONCATENAR(PVALOR1 VARCHAR2, PVALOR2 VARCHAR2) RETURN VARCHAR2
    IS
    
    BEGIN
    RETURN PVALOR1||' '||PVALOR2;
    END FN_CONCATENAR;
END;
-----EJECUCION DEL QUE CUENTA FILAS-----------
DECLARE 
V_TOTAL NUMBER(10);
BEGIN

PKG_TAREA.SP_FILAS_TABLA(ANNO_ATENCION=>2020, PTOTAL=>V_TOTAL);

END;

--EJECUCION DEL QUE CONCATENA
BEGIN
DBMS_OUTPUT.PUT_LINE(PKG_TAREA.FN_CONCATENAR(PVALOR1=>'ALAM', PVALOR2=>'BRITO'));

END;

--TRIGGERS

/*Se ejecutan cuando se realiza un insert update o delete*/
--Si se pone BEFORE, esto se ejecutaria antes que el insert que se quiere realizar, por lo que daría error al no tener la llave primaria ingresada
--por eso se tiene que que poner AFTER
CREATE TRIGGER TRG_REGISTRO_CAMBIO_DATOS_EMP
AFTER INSERT OR UPDATE OR DELETE ON EMPLEADO
FOR EACH ROW
BEGIN
    IF INSERTING THEN
        INSERT INTO HISTORIAL_CAMBIO(ID_EMP, FECHA_ACTUALIZACION, PNOMBRE_ACTUAL, APTERNO_ACTUAL, AMATERNO_ACTUAL, TAREA_DML)
        VALUES(:NEW.ID_EMP,SYSDATE, :NEW.PNOMBRE, :NEW.APTERNO, :NEW.AMATERNO,'INSERT');
    ELSIF UPDATING THEN
        INSERT INTO HISTORIAL_CAMBIO
        VALUES(:OLD.ID_EMP,SYSDATE,:OLD.PNOMBRE,:NEW.PNOMBRE,:OLD.APTERNO,:NEW.APTERNO,:OLD.AMATERNO,:NEW.AMATERNO,'UPDATE');
    ELSIF DELETING THEN
        INSERT INTO HISTORIAL_CAMBIO(ID_EMP, FECHA_ACTUALIZACION, PNOMBRE_ANTERIOR, APTERNO_ANTERIOR, AMATERNO_ANTERIOR, TAREA_DML)
        VALUES(:OLD.ID_EMP,SYSDATE,:OLD.PNOMBRE, :OLD_AMATERNO,'DELETE');
    END IF;
END;



--JANVAPP-----------

SELECT * FROM VIAJES WHERE EXTRACT(MONTH FROM FECHA_VIAJE)=EXTRACT(MONTH FROM SYSDATE)-1

CREATE TRIGGER TRG_CANT_VIAJE
BEFORE INSERT ON CONSOLIDADO_VIAJE_MES
FOR EACH ROW
BEGIN
    UPDATE PASAJERO SET CANT_VIAJES=CANT_VIAJES+1 WHERE CORREO_PAS=:NEW.CORREO_PASAJERO;
    UPDATE CONDUCTOR SET CANT_VIAJES=CANT_VIAJES+1 WHERE CORREO_CON=:NEW.CORREO_CONDUCTOR;

END;


--EJERCICIO TIPO PRUEBA


--Encabezado del package
CREATE PACKAGE PKG_PARQUE
IS
	PROCEDURE SP_PROCESA_ANULA_RESERVA(PMES_ANNO VARCHAR2);
	PROCEDURE SP_PROCESA_ANULA_CLIENTE(PNUM_RES NUMBER,PID_CLI NUMBER);
	FUNCTION FN_MAX_TOTA_ADULTO_CAB(PNUM_CAB NUMBER) RETURN NUMBER;
	FUNCTION FN_MAX_INFANTE_CAB(PNUM_CAB NUMBER) RETURN NUMBER;
	FUNCTION FN_MAX_TOTAL_CAB(PNUM_CAB NUMBER) RETURN NUMBER;

END;

--Body del package
--En este ejemplo se pone NULL y return 0 para que lo compile 
--luego se edita...

CREATE PACKAGE BODY PKG_PARQUE
IS
	PROCEDURE SP_PROCESA_ANULA_RESERVA(PANNO_MES VARCHAR2);
	IS
	BEGIN
		NULL;
	END SP_PROCESA_ANULA_RESERVA;


	FUNCTION FN_MAX_TOTA_ADULTO_CAB(PNUM_CAB NUMBER) RETURN NUMBER
	IS
	BEGIN
		RETURN 0;
	END FN_MAX_TOTA_ADULTO_CAB;

	FUNCTION FN_MAX_INFANTE_CAB(PNUM_CAB NUMBER) RETURN NUMBER
	IS

	BEGIN
		RETURN 0;
	END FN_MAX_INFANTE_CAB;

	FUNCTION FN_MAX_TOTAL_CAB(PNUM_CAB NUMBER) RETURN NUMBER
	IS
	
	BEGIN
		RETURN 0;
	END FN_MAX_TOTAL_CAB;

END;


--Lo compilado

CREATE PACKAGE BODY PKG_PARQUE
IS
	PROCEDURE SP_PROCESA_ANULA_RESERVA(PANNO_MES VARCHAR2)
	IS
		CURSOR C_ANUL_RESERVA(PFECHA VARCHAR2) IS
			SELECT R.NUM_RESERVA, R.CHECK_IN, R.CHECK_OUT, R.MONTO_RESERVA, R.ESTADO,
			R.CANT_ADULTOS, R.CANT_INFANTES, R.ID_CLIENTE, R.NUM_CABANNA,
			C.NOM_CLIENTE||' '||C.PAT_CLIENTE||' '||C.MAT_CLIENTE NOM_CLI,
			C.NUM_CUENTA_BANCO, C.CORREO_CLIENTE
			FROM RESERVA R INNER JOIN CLIENTE C ON C.ID_CLIENTE=R.ID_CLIENTE
			WHERE TO_CHAR(CHECK_IN, 'YYYYMM')='202202' AND ESTADO IS NULL;

			V_CANT_ADUL NUMBER(6);
			V_CANT_INFANT NUMBER(6);
			V_CANT_TOTAL NUMBER(6);
			V_MEN VARCHAR2(400);
		
	BEGIN
		FOR R_ANULA IN C_ANUL_RESERVA(PFECHA=>(PMES_ANNO) LOOP
			V_MEN:='';
			V_CANT_ADUL:=FN_MAX_TOTA_ADULTO_CAB(R_ANULA.NUM_CABANNA);
			V_CANT_INFANT:=FN_MAX_INFANTE_CAB(R_ANULA.NUM_CABANNA);
			V_CANT_TOTAL:=FN_MAX_TOTAL_CAB(R_ANULA.NUM_CABANNA);

			IF R_ANULA.CANT_ADULTOS>V_CANT_ADUL OR R_ANULA.CANT_INFANTES>V_CANT_INFANT OR R_ANULA.CANT_INFANTES+R_ANULA.CANT_ADULTOS>V_CANT_TOTAL THEN
				V_MEN:='Estimado cliente: '||R_ANULA.NOM_CLI||' su reserva sera anulada';
			
				UPDATE RESERVA SET ESTADO='ANULADO', MONTO_RESERVA=0 WHERE NUM_RESERVA=R_ANULA.NUM_RESERVA;


				INSERT INTO MENSAJE_AUTOM_ANULA_CORREO VALUES
				(R_ANULA.NUM_RESERVA, R_ANULA.NOM_CLI, R_ANULA.CORREO_CLIENTE, R_ANULA.CHECK_IN, R_ANULA.CHECK_OUT, R_ANULA.MONTO_RESERVA,
				R_ANULA.NUM_CUENTA_BANCO, V_MEN);
		
			
			
			END IF;
		END LOOP;
	END SP_PROCESA_ANULA_RESERVA;


	FUNCTION FN_MAX_TOTA_ADULTO_CAB(PNUM_CAB NUMBER) RETURN NUMBER
	IS
		V_CANT NUMBER(10);
	BEGIN

		--SQL dinamico
		EXECUTE IMMEDIATE 'SELECT CANT_ADULTO_MAX FROM CABANNA WHERE NUM_CABANNA=:VALOR'
						--PNUM_CAB se esta asignando a :VALOR
						--se puede asignar mas de una variable con el using , dentro del execute se pone con dos puntos :
						--y en el using se tiene que respetar la posicion
				INTO V_CANT USING PNUM_CAB; 
		RETURN  V_CANT ;
	EXCEPTION
		WHEN OTHERS THEN
			RETURN 0;
	END FN_MAX_TOTA_ADULTO_CAB;

	FUNCTION FN_MAX_INFANTE_CAB(PNUM_CAB NUMBER) RETURN NUMBER
	IS
		V_CANT NUMBER(10);
	BEGIN
		--SQL dinamico
		EXECUTE IMMEDIATE 'SELECT CANT_INFANTE_MAX FROM CABANNA WHERE NUM_CABANNA=:VALOR'
						--PNUM_CAB se esta asignando a :VALOR
				INTO V_CANT USING PNUM_CAB; 
		RETURN  V_CANT ;
	EXCEPTION
		WHEN OTHERS THEN
			RETURN 0;
	END FN_MAX_INFANTE_CAB;

	FUNCTION FN_MAX_TOTAL_CAB(PNUM_CAB NUMBER) RETURN NUMBER
	IS
		V_CANT NUMBER(10);
	BEGIN
		--SQL dinamico
		EXECUTE IMMEDIATE 'SELECT CANT_TOTAL_PERSONAS FROM CABANNA WHERE NUM_CABANNA=:VALOR'
						--PNUM_CAB se esta asignando a :VALOR
				INTO V_CANT USING PNUM_CAB; 
		RETURN  V_CANT ;
	EXCEPTION
		WHEN OTHERS THEN
			RETURN 0;
	END FN_MAX_TOTAL_CAB;





	PROCEDURE SP_PROCESA_ANULA_CLIENTE(PNUM_RES NUMBER,PID_CLI NUMBER)
	IS
	
			V_MEN VARCHAR2(400);
			R_RES RESERVA%ROWTYPE;
			R_CLI CLIENTE%ROWTYPE;
		
	BEGIN
		SELECT * INTO R_RES
		FROM RESERVA 
		WHERE ESTADO IS NULL AND ID_CLIENTE=PID_CLI AND NUM_RESERVA=PNUM_RES;


		SELECT * INTO R_CLI
		FROM CLIENTE WHERE ID_CLIENTE=PID_CLI;	


		V_MEN:='Estimado cliente: '||R_CLI.NOM_CLIENTE||' su reserva sera anulada';
		UPDATE RESERVA SET ESTADO='ANULADO' MONTO_RESERVA=R_RES.MONTO_RESERVA*0.2 WHERE NUM_RESERVA=PNUM_RES;


		INSERT INTO MENSAJE_AUTOM_ANULA_CORREO VALUES
				(PNUM_RES, R_CLI.NOM_CLIENTE, R_CLI.CORREO_CLIENTE, R_RES.CHECK_IN, R_RES.CHECK_OUT, R_RES.MONTO_RESERVA*0.8,
				R_CLI.NUM_CUENTA_BANCO, V_MEN);
	END SP_PROCESA_ANULA_RESERVA;



END;




/*el procedimiento, como tiene que modificar valores de una tabla
en este caso el estado, y debe recibir valores NULL, etc
se hará un SELECT con la condicion de que sea null y que esté dentro
del año y mes y seleccionado, este caso 202202
*/
/*Lo que esto devuelve son las reservas que el sistema debe analizar
si debe anular o no, en caso de que sobrepasen el maximo de personas,
además debe devolver el dinero*/


--Este select será el cursor del procedimiento del package
SELECT R.NUM_RESERVA, R.CHECK_IN, R.CHECK_OUT, R.MONTO_RESERVA, R.ESTADO,
R.CANT_ADULTOS, R.CANT_INFANTES, R.ID_CLIENTE, R.NUM_CABANNA,
C.NOM_CLIENTE||' '||C.PAT_CLIENTE||' '||C.MAT_CLIENTE NOM_CLI,
C.NUM_CUENTA_BANCO
FROM RESERVA r INNER JOIN CLIENTE C ON C.ID_CLIENTE=R.ID_CLIENTE

WHERE TO_CHAR(CHECK_IN, 'YYYYMM')='202202' AND ESTADO IS NULL;


/*Se hace un SELECT de todas las cabañas solo para ver el maximo
y asi comparar la reserva con el maximo que admite la cabaña*/
SELECT * FROM CABANNA;


--Ejecucion de los procedimientos del package...

EXECUTE PKG_PARQUE.SP_PROCESA_ANULA_RESERVA(PANNO_MES=>'202202');
EXECUTE PKG_PARQUE.SP_PROCESA_ANULA_CLIENTE(1008,3);



--para el trigger que calcula el valor de la reserva,
--obtendrá el valor por dia desde la tabla cabaña y luego
--lo multiplica por la cantidad de dias


INSERT INTO RESERVA('04/02/2022', '10/02/2022', 11)

V_DIAS= :NEW.CHECKOUT-:NEW.CHECKIN=>

SELECT VALOR_DIA_RESERVA FROM CABANNA WHERE NUM_CABANNA=:NEW.NUM_CABANNA;

:NEW.MONTO_RESERVA:=V_DIAS*VALOR_DIA_RESERVA


EL TRIGGER DEBE SER BEFORE


SIN FOR EACH ROW NO SE PUEDEN UTILIZAR PSEUDOREGISTROS :NEW, :OLD



--Procedimiento para ingresar reservas exemplo que no funciona...

/*

CREATE PROCEDURE INGRESAR_RESERVA(P1 VARCHAR2,P2 ETC...,P3,P4,P5,P6,P7,P8,P9)
IS
BEGIN

	INSERT INTO RESERVA
	VALUES(V_CALCULAR(para el n de reserva, debe ser un select
		max del n de reserva, asignarlo a una variable y
		sumarle 1, algunos valores como el estado y el valor se
		dejarian en 0 o vacio, ya que el trigger se encarga de eso))
END;

*/


--Procedimiento para insertar reservas que si funciona

PROCEDURE SP_AGREGA_RESERVA(PCHECK_IN DATE, PCHECK_OUT DATE, PMONTO_RESERVA NUMBER,
    PESTADO VARCHAR2, PCANT_ADULTOS NUMBER, PCANT_INFANTES NUMBER, PID_CLIENTE NUMBER,
    PNUM_CABANNA NUMBER, PID_FUNCIONARIO NUMBER)
    IS
    V_NRES NUMBER(10);
    BEGIN
    EXECUTE IMMEDIATE 'SELECT MAX(NUM_RESERVA) FROM RESERVA'
    INTO V_NRES;
    INSERT INTO RESERVA
    VALUES(V_NRES+1, PCHECK_IN, PCHECK_OUT, PMONTO_RESERVA, PESTADO, PCANT_ADULTOS, PCANT_INFANTES, PID_CLIENTE, PNUM_CABANNA, PID_FUNCIONARIO);


    END SP_AGREGA_RESERVA;


--Trigger que calcula el valor y el estado


create or replace TRIGGER TRG_NUEVA_RESERVA
BEFORE INSERT ON RESERVA
FOR EACH ROW
DECLARE 

V_VALOR NUMBER(10);
V_DIAS NUMBER(10);
V_VALORFINAL NUMBER(10);

BEGIN
    V_DIAS:=:NEW.CHECK_OUT-:NEW.CHECK_IN;
    
    EXECUTE IMMEDIATE 'SELECT VALOR_DIA_CABANNA FROM CABANNA WHERE NUM_CABANNA=:NUMCA'
        INTO V_VALOR USING :NEW.NUM_CABANNA;
        
    V_VALORFINAL:=V_DIAS*V_VALOR;
    IF INSERTING THEN
        :NEW.ESTADO:='ESPERANDO CONFIRMACION';
        :NEW.MONTO_RESERVA:=V_VALORFINAL;
    END IF;
END;


--asi se insertan reservas utilizando el procedimiento

EXECUTE PKG_PARQUE.SP_AGREGA_RESERVA(TO_DATE('01/03/2022', 'DD/MM/YYYY'), TO_DATE('07/03/2022', 'DD/MM/YYYY'),0,'',2,1,6,10,55);







---EJERCICIO 3.5



--PACKAGE----------------------------------------------------------------

create or replace PACKAGE BODY PKG_REAJUSTE
IS
    PROCEDURE SP_ERROR_PROC(PREAJUSTE NUMBER)
    IS
    BEGIN
        IF PREAJUSTE>101299 THEN
            
            INSERT INTO ERROR_PROCESO
            VALUES(SEQ_ERROR.NEXTVAL,'SUPERA LAS 5 UF', 'SE SUPERAN LAS 5 UF' );
        
        END IF;
    
    END SP_ERROR_PROC;
    FUNCTION FN_TOTAL_CREDITOS(PNRO_SOCIO NUMBER) RETURN NUMBER
    IS
    V_CREDITOS NUMBER(10);
    BEGIN
        EXECUTE IMMEDIATE 'SELECT COUNT(NRO_SOCIO) FROM CREDITO_SOCIO WHERE NRO_SOCIO=PNRO_SOCIO GROUP BY NRO_SOCIO'
        INTO V_CREDITOS USING PNRO_SOCIO;
    END FN_TOTAL_CREDITOS;

END;


-----------------------------------------------------------------------------------

PROCEDIMIENTO PRINCIPAL
-----------------------------------------------------------------

create or replace PROCEDURE SP_REAJUSTE_TOTAL(PIPC NUMBER)
IS
CURSOR C_PIS IS
SELECT NRO_SOLIC_PROD, NRO_SOCIO, MONTO_TOTAL_AHORRADO, COD_PROD_INV
FROM PRODUCTO_INVERSION_SOCIO WHERE EXTRACT(YEAR FROM FECHA_SOLIC_PROD)=EXTRACT(YEAR FROM SYSDATE);

V_REAJUSTE NUMBER(10);
V_TOTALCREAJ NUMBER (10);
V_TOTAL_ABONOS NUMBER(10);
V_COTORANNO NUMBER(10);
V_TASA_INTERES NUMBER(10);
ERR_MASDE_UF EXCEPTION;
BEGIN 

FOR R_PIS IN C_PIS LOOP
V_TOTALCREAJ:=0;
V_REAJUSTE:=0;
V_TOTAL_ABONOS:=0;
V_COTORANNO:=0;
V_TASA_INTERES:=0;


    V_REAJUSTE:=R_PIS.MONTO_TOTAL_AHORRADO*(PIPC/100);
    
    V_TOTALCREAJ:=R_PIS.MONTO_TOTAL_AHORRADO+V_REAJUSTE;
    
    IF FN_TOTAL_PIC(R_PIS.NRO_SOCIO)>1 THEN
    V_REAJUSTE:=V_REAJUSTE+V_REAJUSTE*(FN_TOTAL_PIC(R_PIS.NRO_SOCIO)/100);
    END IF;
    
BEGIN
EXECUTE IMMEDIATE 'SELECT SUM(MONTO_MOVIMIENTO) FROM MOVIMIENTO
WHERE EXTRACT(YEAR FROM FECHA_MOVIMIENTO)=EXTRACT(YEAR FROM SYSDATE) AND COD_TIPO_MOV=1 AND NRO_SOCIO=:NROS
GROUP BY NRO_SOCIO'
INTO V_TOTAL_ABONOS USING R_PIS.NRO_SOCIO;

EXCEPTION WHEN OTHERS THEN
V_TOTAL_ABONOS:=0;


END;
IF V_TOTAL_ABONOS>1000000 THEN

    V_REAJUSTE:=V_REAJUSTE+V_REAJUSTE*(1/100);
END IF;
BEGIN
    EXECUTE IMMEDIATE 'SELECT COUNT(NRO_SOCIO) FROM CREDITO_SOCIO WHERE EXTRACT(YEAR FROM FECHA_OTORGA_CRED)=EXTRACT(YEAR FROM SYSDATE) AND NRO_SOCIO=:NROS GROUP BY NRO_SOCIO'
    INTO V_COTORANNO USING R_PIS.NRO_SOCIO;
    
    EXCEPTION WHEN OTHERS THEN
        V_COTORANNO:=0;
        
END;
    
    IF V_COTORANNO>0 THEN
        EXECUTE IMMEDIATE 'SELECT MAX(TASA_INTERES_ANUAL) FROM 
        CREDITO CR INNER JOIN CREDITO_SOCIO CS ON CR.COD_CREDITO=CS.COD_CREDITO WHERE CS.NRO_SOCIO=:NSOC
        GROUP BY NRO_SOCIO'
        INTO V_TASA_INTERES USING R_PIS.NRO_SOCIO;
        
        V_REAJUSTE:=V_REAJUSTE+(V_TASA_INTERES*0.5);
    END IF;
    
    PKG_REAJUSTE.SP_ERROR_PROC(V_REAJUSTE);
    
    IF V_REAJUSTE>101299 THEN
    V_REAJUSTE:=101299;
    END IF;
    --
    BEGIN
        IF V_REAJUSTE>405180 THEN
        
            RAISE ERR_MASDE_UF;
        
        END IF;
        
        EXCEPTION WHEN ERR_MASDE_UF THEN
        V_REAJUSTE:=101299;
            INSERT INTO ERROR_PROCESO
            VALUES(SEQ_ERROR.NEXTVAL,'SUPERA LAS 20 UF', 'SE SUPERAN LAS 20 UF' );
        
        END;
    --
    INSERT INTO REAJUSTE_PRODINV_SOCIO(NRO_SOLIC_PROD, NRO_SOCIO, MONTO_TOTAL_AHORRADO_SREAJ, MONTO_REAJUSTE,
    MONTO_TOTAL_AHORRADO_CREAJ, COD_PROD_INV)
    VALUES(R_PIS.NRO_SOLIC_PROD, R_PIS.NRO_SOCIO, R_PIS.MONTO_TOTAL_AHORRADO,V_REAJUSTE, V_TOTALCREAJ, R_PIS.COD_PROD_INV );
    
    
    UPDATE PRODUCTO_INVERSION_SOCIO SET MONTO_TOTAL_AHORRADO=V_TOTALCREAJ;

END LOOP;

END;



------------------------------------------------------------------

FUNCION ALMACENADA
------------------------------------------------------------------------


create or replace FUNCTION FN_TOTAL_PIC(PNRO_SOCIO NUMBER) RETURN NUMBER
IS
V_TOTAL_PIS NUMBER(10);
BEGIN

    EXECUTE IMMEDIATE 'SELECT COUNT(NRO_SOCIO) FROM PRODUCTO_INVERSION_SOCIO WHERE NRO_SOCIO=:NROSOC GROUP BY NRO_SOCIO'
    INTO V_TOTAL_PIS USING PNRO_SOCIO;
    
    RETURN V_TOTAL_PIS;
    
    
	EXCEPTION
		WHEN OTHERS THEN
			RETURN 0;
END;

--------------------------------------------------------------------------------------

--Lo que tenia escrito en la hoja principal...


CREATE PACKAGE PKG_REAJUSTE
IS
    PROCEDURE SP_ERROR_PROC;
    FUNCTION FN_TOTAL_CREDITOS(PNRO_SOCIO);

END;

CREATE PACKAGE BODY PKG_REAJUSTE
IS
    PROCEDURE SP_ERROR_PROC IS
        NULL
    
    END SP_ERROR_PROC;
    FUNCTION FN_TOTAL_CREDITOS(PNRO_SOCIO NUMBER) RETURN NUMBER
    IS
    
        RETURN NULL;
    END FN_TOTAL_CREDITOS;

END;
SELECT * FROM CREDITO_SOCIO
SELECT COUNT(NRO_SOCIO) FROM CREDITO_SOCIO WHERE NRO_SOCIO=70 GROUP BY NRO_SOCIO


SELECT COUNT(NRO_SOCIO) FROM PRODUCTO_INVERSION_SOCIO GROUP BY NRO_SOCIO



SELECT NRO_SOLIC_PROD, NRO_SOCIO, MONTO_TOTAL_AHORRADO, COD_PROD_INV
FROM PRODUCTO_INVERSION_SOCIO

SELECT SUM(MONTO_MOVIMIENTO) FROM MOVIMIENTO
WHERE EXTRACT(YEAR FROM FECHA_MOVIMIENTO)=EXTRACT(YEAR FROM SYSDATE) AND COD_TIPO_MOV=1
GROUP BY NRO_SOCIO;


SELECT COUNT(NRO_SOCIO), NRO_SOCIO FROM CREDITO_SOCIO 
WHERE EXTRACT(YEAR FROM FECHA_OTORGA_CRED)=EXTRACT(YEAR FROM SYSDATE) --AND NRO_SOCIO=1
GROUP BY NRO_SOCIO;

SELECT MAX(TASA_INTERES_ANUAL), NRO_SOCIO FROM 
        CREDITO CR INNER JOIN CREDITO_SOCIO CS ON CR.COD_CREDITO=CS.COD_CREDITO WHERE CS.NRO_SOCIO=38 GROUP BY NRO_SOCIO

WHERE

CREATE SEQUENCE SQ_ERRPRC


EXECUTE SP_REAJUSTE_TOTAL(2)

SELECT * FROM REAJUSTE_PRODINV_SOCIO
